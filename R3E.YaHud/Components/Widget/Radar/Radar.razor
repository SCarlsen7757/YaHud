@using R3E.YaHud.Components.UI.Helpers
@using R3E.YaHud.Components.Widget.Core
@using R3E.YaHud.Components.Widget.MoTec.Components
@using R3E.API
@using System.Numerics
@using System.Globalization
@inherits HudWidgetBase<RadarSettings>

@if (Settings?.Visible ?? false)
{
    <div id=@ElementId class="radar-widget">
        <div id="radar" @ref="radarElement" style="@RadarStyling.ToString()">
            @foreach (var child in radarChildren)
            {
                <div id="@child" class="@driverStyling.GetValueOrDefault(child)!.classlist.ToString()" style="@driverStyling.GetValueOrDefault(child)!.ToString()">

                </div>
            }
        </div>
    </div>
}


@code {

    public override string ElementId { get => "radarWidget"; }
    public override string Name => "Radar";
    public override string Category => "Telemetry";
    public override bool Collidable => false;

    public override double DefaultXPercent => 90;
    public override double DefaultYPercent => 90;
    private static string RadarGridImagePath = $"assets/img/radar/radar-grid.png";
    private StylingElement RadarStyling = new StylingElement();

    private Dictionary<int, DriverState> drivers = new Dictionary<int, DriverState>();
    private List<int> radarChildren = new List<int>();
    private Dictionary<int, StylingElement> driverStyling = new Dictionary<int, StylingElement>();
    private bool RadarPointer = true;
    private ElementReference radarElement;
    private double radarWidth;

    public Radar()
    {
        RadarStyling.setStyle("background-image", $"radial-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.4) ), url({RadarGridImagePath})");
        UseR3EData = true;
        UpdateInterval = TimeSpan.FromMilliseconds(30);
    }

    protected override void UpdateWithTestData()
    {

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);
        if (firstRender)
        {
            if(radarElement.Context != null)
            {
                radarWidth = await JS.InvokeAsync<double>(
                    "radarInterop.getOffsetWidth",
                    radarElement
                );

                StateHasChanged();
            }

        }
    }

    protected override void Update()
    {
        if (Settings is null) return;
        R3E.Data.Shared data = TelemetryService.Data.Raw;
        if (data.DriverData == null)
            return;

        foreach (var driver in data.DriverData)
        {
            drivers.TryAdd(driver.DriverInfo.SlotId, new DriverState());
        }

        var rotationMatrix = RotationMatrixFromEuler(data.Player.Orientation);
        var pointerStartRange = Settings.RadarRange * 1.1;
        var radarFadeRange = Settings.RadarRange + Settings.RadarFadeRange;

        var ownDriver = data.DriverData.FirstOrDefault(d => d.DriverInfo.UserId == data.Player.UserId);
        if (ownDriver.DriverInfo.UserId != data.Player.UserId)
            return;

        var ownPlace = ownDriver.Place;

        foreach (var driver in data.DriverData)
        {
            var slot = driver.DriverInfo.SlotId;
            if (ownPlace != driver.Place)
            {
                drivers[slot].RelativePos = RotateVector(rotationMatrix, SubtractVector(ownDriver.Position, driver.Position));
                var tmp = SubtractVector(driver.Orientation, ownDriver.Orientation);
                drivers[slot].RelativeOri = new Vector3(tmp.X, tmp.Y, tmp.Z);
            }
            drivers[slot].DriverData = driver;
        }

        var closeBySlot = drivers
            .Where(kvp => DistanceFromZero(kvp.Value.RelativePos) < radarFadeRange)
            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

        double? closest = null;
        int closeLeft = 0;
        int closeRight = 0;

        foreach (var kv in drivers)
        {
            var slotId = kv.Key;
            var dd = kv.Value.DriverData;
            if (!radarChildren.Contains(slotId))
                radarChildren.Add(slotId);
            if (!driverStyling.ContainsKey(slotId))
            {
                var se = new StylingElement();
                se.setStyle("display", "none");
                se.classlist.add("radar-car");
                driverStyling[slotId] = se;
            }
        }
        var batch = new List<object>(radarChildren.Count);

        foreach (var childSlotId in radarChildren)
        {
            if (!closeBySlot.TryGetValue(childSlotId, out var state))
            {
                if (driverStyling.TryGetValue(childSlotId, out var stylingHidden))
                {
                    stylingHidden.setStyle("display", "none");
                    driverStyling[childSlotId] = stylingHidden;
                }

                batch.Add(new
                {
                    id = childSlotId.ToString(),
                    display = "none",
                    transform = (string?)null,
                    opacity = (string?)null,
                    width = (string?)null,
                    height = (string?)null,
                    classes = driverStyling.GetValueOrDefault(childSlotId)?.classlist.ToString() ?? ""
                });
                continue;
            }

            var child = driverStyling[childSlotId];
            var driverState = state;
            var driverRotation = driverState.RelativeOri.Y;
            var driverLeftRight = driverState.RelativePos.X;
            var driverFrontBack = driverState.RelativePos.Z;

            var carWidth = (double)driverState.DriverData.DriverInfo.CarWidth;
            var carLength = (double)driverState.DriverData.DriverInfo.CarLength;

            var distance = DistanceFromZero(driverState.RelativePos);

            if (distance < Settings.RadarRange)
            {
                if (driverLeftRight < 0 && (Math.Abs(driverFrontBack) < Math.Abs(driverLeftRight) || Math.Abs(driverFrontBack) <= carLength))
                    closeLeft = 1;
                else if (driverLeftRight > 0 && (Math.Abs(driverFrontBack) < Math.Abs(driverLeftRight) || Math.Abs(driverFrontBack) <= carLength))
                    closeRight = 1;
            }

            driverFrontBack = -driverFrontBack;

            var width = carWidth / Settings.RadarRange * radarWidth / 2;
            var height = carLength / Settings.RadarRange * radarWidth / 2;

            string transformStr;
            string opacityStr;

            if (RadarPointer && distance > pointerStartRange)
            {
                var pointerRotation = GetRadarPointerRotation(distance, driverState.RelativePos.X, driverState.RelativePos.Z);
                var pointerOpacity = Math.Pow((distance - radarFadeRange) / (Settings.RadarRange - radarFadeRange), 0.5);

                child.setStyle("display", null);
                child.setStyle("background-color", "red");
                child.setStyle("border-radius", "0px");
                child.setStyle("width", FmtPx(width));
                child.setStyle("height", "20px");
                child.setStyle("translate", "-50% -50%");
                transformStr = driverState.RelativePos.Z > 0 ? $"rotate({Fmt(pointerRotation)}rad) translate3d(0px,-150px,0px)" : $"rotate({Fmt(pointerRotation)}rad) translate3d(0px,150px,0px)";
                child.setStyle("transform", transformStr);
                opacityStr = Fmt(pointerOpacity);
                child.setStyle("opacity", opacityStr);
                driverStyling[childSlotId] = child;

                batch.Add(new
                {
                    id = childSlotId.ToString(),
                    display = "",
                    transform = transformStr,
                    opacity = opacityStr,
                    width = FmtPx(width),
                    height = "20px",
                    classes = child.classlist.ToString()
                });
            }
            else
            {
                var leftVal = (driverLeftRight / Settings.RadarRange) * radarWidth / 2 + radarWidth / 2 - width / 2;
                var topVal = (driverFrontBack / Settings.RadarRange) * radarWidth / 2 + radarWidth / 2 - height / 2;

                transformStr = $"translate3d({FmtPx(leftVal)},{FmtPx(topVal)},0) rotate({Fmt(driverRotation)}rad)";
                opacityStr = "1";

                child.setStyle("display", null);
                child.setStyle("background-color", ownPlace == driverState.DriverData.Place ? "white" : "red");
                child.setStyle("border-radius", "6px");
                child.setStyle("left", FmtPx(leftVal));
                child.setStyle("top", FmtPx(topVal));
                child.setStyle("width", FmtPx(width));
                child.setStyle("height", FmtPx(height));
                child.setStyle("translate", "none");
                child.setStyle("transform", $"rotate({Fmt(driverRotation)}rad)");
                child.setStyle("opacity", "1");
                driverStyling[childSlotId] = child;

                batch.Add(new
                {
                    id = childSlotId.ToString(),
                    display = "",
                    transform = transformStr,
                    opacity = opacityStr,
                    width = FmtPx(width),
                    height = FmtPx(height),
                    classes = child.classlist.ToString()
                });
            }

            if (ownDriver.DriverInfo.SlotId == driverState.DriverData.DriverInfo.SlotId)
            {
                child.classlist.add("radar-car-self");
                driverStyling[childSlotId] = child;
            }
            else
            {
                if (closest == null || distance < closest)
                    closest = distance;

                child.classlist.remove("radar-car-self");
                driverStyling[childSlotId] = child;
            }
        }

        if (closeLeft == 1)
        {
            var driverCloseLeftImg = "assets/img/radar/radar-grid-warning-left.png";
            RadarStyling.appendStyleString("background-image", $",url({driverCloseLeftImg})");
        }
        else
        {
            var driverCloseLeftImg = "assets/img/radar/radar-grid-warning-left.png";
            RadarStyling.removeStyleString("background-image", $",url({driverCloseLeftImg})");
        }
        if (closeRight == 1)
        {
            var driverCloseRightImg = "assets/img/radar/radar-grid-warning-right.png";
            RadarStyling.appendStyleString("background-image", $",url({driverCloseRightImg})");
        }
        else
        {
            var driverCloseRightImg = "assets/img/radar/radar-grid-warning-right.png";
            RadarStyling.removeStyleString("background-image", $",url({driverCloseRightImg})");
        }

        if (Settings.AutoHideRadar)
        {
            if (closest == null || closest > radarFadeRange)
            {
                RadarStyling.setStyle("opacity", "0");
                if(Settings.UseJsBatching)
                    _ = JS.InvokeVoidAsync("radarInterop.updateDrivers", batch);
                return;
            }

            var opacityValue = closest.Value < Settings.RadarRange ? Settings.RadarOpacity : ((closest.Value - radarFadeRange) / (Settings.RadarRange - radarFadeRange)) * Settings.RadarOpacity;

            RadarStyling.setStyle("opacity", Fmt(opacityValue));
        }
        if (Settings.UseJsBatching)
            _ = JS.InvokeVoidAsync("radarInterop.updateDrivers", batch);
    }


    private static double[,] RotationMatrixFromEuler(R3E.Data.Vector3<Double> euler)
    {
        double x = -euler.X;
        double y = -euler.Y;
        double z = -euler.Z;

        double c1 = Math.Cos(x);
        double s1 = Math.Sin(x);
        double c2 = Math.Cos(y);
        double s2 = Math.Sin(y);
        double c3 = Math.Cos(z);
        double s3 = Math.Sin(z);

        return new double[,]
        {
            { c2 * c3, -c2 * s3, s2 },
            { c1 * s3 + c3 * s1 * s2, c1 * c3 - s1 * s2 * s3, -c2 * s1 },
            { s1 * s3 - c1 * c3 * s2, c3 * s1 + c1 * s2 * s3, c1 * c2 }
        };
    }

    public static Vector3 RotateVector(double[,] matrix, R3E.Data.Vector3<Double> vector)
    {
        float x = (float)(matrix[0, 0] * vector.X + matrix[0, 1] * vector.Y + matrix[0, 2] * vector.Z);
        float y = (float)(matrix[1, 0] * vector.X + matrix[1, 1] * vector.Y + matrix[1, 2] * vector.Z);
        float z = (float)(matrix[2, 0] * vector.X + matrix[2, 1] * vector.Y + matrix[2, 2] * vector.Z);

        return new Vector3(x, y, z);
    }

    public static Vector3 RotateVector(double[,] matrix, R3E.Data.Vector3<float> vector)
    {
        float x = (float)(matrix[0, 0] * vector.X + matrix[0, 1] * vector.Y + matrix[0, 2] * vector.Z);
        float y = (float)(matrix[1, 0] * vector.X + matrix[1, 1] * vector.Y + matrix[1, 2] * vector.Z);
        float z = (float)(matrix[2, 0] * vector.X + matrix[2, 1] * vector.Y + matrix[2, 2] * vector.Z);

        return new Vector3(x, y, z);
    }

    public static Vector3 SubtractVector(Vector3 a, Vector3 b)
    {
        return new Vector3(a.X - b.X, a.Y - b.Y, a.Z - b.Z);
    }

    public static R3E.Data.Vector3<float> SubtractVector(R3E.Data.Vector3<float> a, R3E.Data.Vector3<float> b)
    {
        return new R3E.Data.Vector3<float>
        {
            X = a.X - b.X,
            Y = a.Y - b.Y,
            Z = a.Z - b.Z
        };
    }

    public double DistanceFromZero(Vector3 v)
    {
        return Math.Sqrt(v.X * v.X + v.Z * v.Z);
    }

    public static double GetRadarPointerRotation(double d, double x, double z)
    {
        double angle = Math.Acos(Math.Abs(z) / d);

        if (x > 0 && z > 0)
        {
            return angle;
        }
        else if (x > 0 && z < 0)
        {
            return -angle;
        }
        else if (x < 0 && z > 0)
        {
            return -angle;
        }
        else
        {
            return angle;
        }
    }

    private static string Fmt(double v) =>
        v.ToString("G", CultureInfo.InvariantCulture);

    private static string FmtPx(double v) =>
        Fmt(v) + "px";
    
    
}
